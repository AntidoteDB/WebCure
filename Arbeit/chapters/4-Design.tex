\chapter{Design}
\label{Design}

In this chapter, we are going to, firstly, introduce the requirements and assumptions we make for the design of WebCure. Having set them, afterwards, we will in detail describe the design of the system.

\section{Requirements}
\label{4-Requirements}

We listed the functional requirements of the WebCure in \tableref*{table:req1} and non-functional requirements in \tableref*{table:req2}.

\begin{table}[!htbp]
\centering
\caption{Functional requirements.}
\label{table:req1}
\begin{tabular}{|p{1cm}|p{14cm}|}
\hline
R1 & Retrieval, increment and decrement of the Counter CRDT should be possible.                         \\ \hline
R2 & Retrieval, adding and removing elements from the Set CRDT should be possible.                       \\ \hline
R3 & Retrieval, assigning and resetting the Multi-Value Register CRDT should be possible.               \\ \hline
R4 & Retrieval elements of any supported CRDTs should be possible according to the passed timestamp. \\ \hline
R5 & Do not store the element's values in the cache, if they were requested at specific timestamp (for the matter of having only the latest data on the client's side). \\ \hline
R6 & The user should be able to remove from the client any stored data element. \\ \hline
R7 & It should not be possible to create elements of different CRDTs with the same name (due to limitations of AntidoteDB). \\ \hline
R8 & When offline, it should be possible to perform operations on supported CRDTs. \\ \hline
R9 & Any operations performed offline, once the connection is restored, should be sent to the server immediately. \\ \hline
R10 & When the connection is reestablished after having data changes in offline mode, the client storage should be updated appropriately (with a consideration of the client's offline changes and possible changes on the server). \\ \hline
\end{tabular}
\caption*{}
\end{table}

\begin{table}[!htbp]
\centering
\caption{Non-functional requirements.}
\label{table:req2}
\begin{tabular}{|p{1cm}|p{14cm}|}
\hline
NFR1 & The web application should be available online and offline (except for the functionality with timestamp-related updates). \\ \hline
NFR2 & The web application should be available with a poor internet connection. \\ \hline
\end{tabular}
\caption*{}
\end{table}

\section{Assumptions}

In this section, we are going to give a list of assumptions we make for the WebCure. 

\begin{enumerate}
\item {\textbf{Timestamps}. Firstly, the database storage used for the server's side should have the concept of timestamps (like in AntidoteDB, described in \secref*{2-antidotedb}), in order for the protocol we are going to describe in the \secref*{4-protocol} to work correctly.}
\item {\textbf{Cache is persistent}. For the WebCure to work online and, especially, offline, we believe that the browser's cache is safe from automatic clearing. Contrarily, if the cache could be cleared automatically depending on the browser's behaviour, it makes it impossible to support the claim that the application can work offline. To guarantee this assumption, a Persistent Storage API described in \secref*{persistentstorage} can be used.}
\item{\textbf{Name duplicates}. We limit the creation of different CRDT elements with the same name in the system due to limitations of AntidoteDB, as the requirement \textit{R7} describes it in the \tableref*{table:req1}. As AntidoteDB is in the process of ongoing development, currently the database crashes when there is an attempt to create elements of different CRDTs with the same name. Thus, this condition has to be fulfilled.}
\item{\textbf{Server's database is always on}. We assume that the server's database is not going to be reset and lose all its data. As the client entirely relies on the server's storage for the synchronisation and only sends back operations performed offline on client's side, it will be impossible to restore the server's database from the client's storage, even if it was up-to-date before the server's data loss. With additional changes to the current protocol, it might be possible, though, but that is not the topic we cover in this thesis. However, even in such a situation, the client will be able to continue the offline work.}
\end{enumerate}

As we specified the requirements, we can go further into and design the protocol of the system.

\section{Protocol}
\label{4-protocol}

The fundamental part of the WebCure will be its protocol design. We are going to describe it in an event-based way in the form of pseudo-code in the following sections. 

%    \begin{itemize}
   %     \item {A client receives an update from the server}
      %  \item {A client sends an update to the server}
       % \item {Two clients interact with a server}
    %\end{itemize}

\subsection{Data transmission}

As we already remember from the \chapref*{Background}, because AntidoteDB is using CRDT datatypes, the following options are possible to update the database: state-based and operation-based. Due to the time constraints and the amount of work, this thesis will consider only the operation-based approach. Therefore, whenever a client wants to update the database, it will send to the server a list of operations. However, whenever it wants to read the value, it will receive the current state of the object from the database. For this thesis, we are going to use such datatypes as Counters, Sets and Multi-Value Registers, to which the reader was introduced in the \secref*{2-crdts}.

\subsection{Description} 

\begin{figure}[!htb]
    \begin{center}
    \def\svgwidth{0.6\linewidth}
    \input{images/protocol/overview.pdf_tex}
    \caption {An overview of the communication protocol.}
    \label{fig:protocol1}
\end{center}
\end{figure}

Firstly, as we would like to focus on the communication part between a server and a client, let us for now keep both of them as black boxes\footnote{In software engineering, a black box is a system, which can be viewed in terms of its inputs and outputs, without the understanding of its internal workings.\cite{49}}, as they are represented at \figref*{fig:protocol1}. Next, we will go through different stages of their communication and describe, how we handled these processes. 

\subsection*{Graphics notations}

\begin{figure}[!htb]
    \centering
    \def\svgwidth{0.35\linewidth}
    \subfloat[]{{\input{images/notations/timeline.pdf_tex}}}%
    \qquad
    \def\svgwidth{0.35\linewidth}
    \subfloat[]{{\input{images/notations/transmission.pdf_tex}}}%
 \def\svgwidth{0.35\linewidth}
    \subfloat[]{{\input{images/notations/data.pdf_tex}}}%
    \qquad
 \def\svgwidth{0.35\linewidth}
    \subfloat[]{{\input{images/notations/operation.pdf_tex}}}%
    \qquad
    \caption{An overview of notations used in the following chapters for the protocol explanation.}%
    \label{fig:notations}%
\end{figure}

Let us explain the notations, which are going to be used for a further protocol description. At \figref*{fig:notations} \textbf{(a)}, we can see a notation for the timeline, every point of which represents a different timestamp. Timelines will be used for the matter of showing the sequence of events happening.At \figref*{fig:notations} \textbf{(b)}, the arrow shows the transmission of data between a subsystem \textit{A} and subsystem \textit{B}, as well as its direction and a command. \figref*{fig:notations} \textbf{(c)} represents the state of the data on a system's side, while \figref*{fig:notations} \textbf{(d)} points to a timestamp, at which an operation that changes the system's storage was applied.

Next, as we already mentioned, we will explain the protocol in an event-based way. 

\subsection*{A client receives an update from the server}

\begin{figure}[!htb]
    \begin{center}
    \def\svgwidth{\linewidth}
    \input{images/architecture/read.pdf_tex}
    \caption {The communication between a client and a server for the read function.}
    \label{fig:design2}
\end{center}
\end{figure}

Let us assume that a client initiates its work with an empty storage. Then, a user might want to request the actual data from the server. In this case, as can be seen at \figref*{fig:design2}, a user has to pass to the server an \textit{id} of the data to read. If the request is successful, the server is going to respond with a \textit{value} for the requested \textit{id} and the timestamp of the last write -- \textit{t\textsubscript{0}}, so the client will store this information in its own storage.

\begin{lstlisting}[caption={Pseudocode for requesting the data: client.}, label={lst:read1}]
// Read function that pulls database changes
// @param id: the id of the object, for which the update was requested;

function read(id) {
  if (ONLINE) {
    value = fetch(id); // request the value of the data by id from the server
    store(value, timestamp); // store the value and timestamp received from the server on a client's storage
    print(value, timestamp); // print the value and timestamp received from the server to the user
  } else {
    value = fetch(id); // Get the value of the data by id from the cache
    print(value); // print the value to the user
  }
}
\end{lstlisting} 

The pseudocode of the logic for this \textit{read} functionality can be seen at~\lstref*{lst:read1}. If a client is online, then the value and timestamp associated with passed \textit{id} are going to be fetched from the server and, after that, stored on a client's storage and displayed to the user. However, if the client is offline, then the client will try to get the data from the cache for the requested id, or, if there is none, it will show the appropriate message to the user.

A client will always receive either the data associated with the latest timestamp from the server or, if a client chooses to specify the timestamp, it will receive the data associated with that timestamp. 

Now, let us say, that after receiving an element \textit{id} from the server, the client wants to change it and send it back to the server.

\subsection*{A client sends an update to the server}

\begin{figure}[!htb]
    \begin{center}
    \def\svgwidth{\linewidth}
    \input{images/architecture/write.pdf_tex}
    \caption {The communication between a client and a server for the update function.}
    \label{fig:design3}
\end{center}
\end{figure}

Looking at the \figref*{fig:design3}, in the case of writing the information to the server, a client has to send an \textit{id} with an operation to perform. After that, the server is going to apply the received operation on its side and, in case of success, the new state of the data will receive a timestamp \textit{t\textsubscript{1}}, and an acknowledgement of the successful commit will be sent back to the client. What happens in case of unsuccessful acknowledgement will be explained below. 

So, once the client is notified that the update was applied on the server successfully, a user can get the latest changes to the client's side now. Thus, when the read request for \textit{id} is sent again, the server will send back the new value -- \textit{value'} and a new timestamp -- \textit{t\textsubscript{1}}, for the element \textit{id}.

\begin{lstlisting}[caption={Pseudocode for making a request to change the data: client.}, label={lst:update1}]
// Update function that processes user-made update
// @param id: an id for the object that should be updated;
// @param op: operation performed on the object for the specified id
function update(id, op){
    send(id, op); // send an operation to the server for the element id
    if (SUCCESS){
        print("The operation was applied on the server successfully"); 
    }
    else {
        store(op); // store the operation on a client's side in order to try sending it again later
    }
}
\end{lstlisting} 

However, let us look at the pseudocode placed at~\lstref*{lst:update1}. There we can see the function \textit{update}, which has to have access to the parameters \textit{id} and \textit{op} that might be taken from the presentation layer of the system. Afterwards, an attempt is happening to send the operation \textit{op} for the element \textit{id} to the server. If it succeeds, then a success message will be printed. Otherwise, the operation will be stored locally on a client's side. That makes the update available while the user is offline and gives an opportunity to send the operation again when the connection is back again.

Next, let us say that a client loses its network connection, so any updates made from that point onwards will be stored locally.  

\subsection*{Offline behaviour}

\begin{figure}[!htb]
    \begin{center}
    \def\svgwidth{\linewidth}
    \input{images/architecture/offline.pdf_tex}
    \caption {The communication between a client and a server while offline with a transition to online.}
    \label{fig:design4}
\end{center}
\end{figure}

Have a look at the \figref*{fig:design4}, where appropriate markings can clearly distinguish periods when the client was offline and online. The client has an element \textit{id} with a value \textit{value'} at timestamp \textit{t\textsubscript{1}} and then makes a local change applying some operation, which changes the previous value to a new one -- \textit{value''}. Pay attention that a new value does not receive a timestamp assigned to it, while locally: to support the causal consistency claims, the responsibility for assigning timestamps should be taken by the server. Then, after some time, the connection gets back, and the client sends an immediate update message to the server with \textit{id} of an element and the applied operation. The server's side, as was already described above, applies that operation and returns an acknowledgement of success. Eventually, the client sends a \textit{read} message and gets back the \textit{value''} as well as the assigned to it timestamp \textit{t\textsubscript{2}}.

\begin{lstlisting}[caption={Pseudocode for sending offline performed operations to the server: client.}, label={lst:offline}]
// Update function that processes user-made updates performed offline when the connection is restored
// @param offlineOperations: an array that contains all the operations performed on a client's side offline
function synchronize(offlineOperations) {
  if (ONLINE) {
    offlineOperations.forEach(operation => {
      send(operation);
    });
  }
}
\end{lstlisting} 

The logic described above can be seen at the~\lstref*{lst:offline}, which has the function named \textit{synchronize} that should be triggered at the time when the client's side restored a network connection. There, we can see that every operation performed offline is sent once at a time to the server. For causality, the array should be sorted in the order the operations were performed initially.

Now, let us move to the point when more than one client interacts with a server, in order to see how scalable the described protocol is.

\subsection*{Two clients interact with a server.}

\begin{figure}[!htb]
    \begin{center}
    \def\svgwidth{\linewidth}
    \input{images/architecture/twoClients.pdf_tex}
    \caption {The communication between two clients and a server.}
    \label{fig:design5}
\end{center}
\end{figure}

Let us assume that, initially, as can be seen at the \figref*{fig:design5}, the server has a stored element \textit{(id, value)} at the timestamp \textit{t\textsubscript{0}}. Therefore, when both clients request to read the data from the server, they get that data and store it locally. At the representation above, a \textit{Client 1} is acting first and sends an update to the server changing the value of an element \textit{id} to \textit{value'} at \textit{t\textsubscript{1}}. Observe that \textit{Client 1} does not request the latest data from the server and still only has its local changes. In parallel, a \textit{Client 2} makes the change later at time \textit{t\textsubscript{2}}, and an element \textit{id} is now set to \textit{value''}. Then, both clients request the updated data from the server and both receive the actual value of the element \textit{id} at the timestamp \textit{t\textsubscript{2}}, which is \textit{value''}. We would like to stress the point that all systems - the server and both clients end up having the same data.

Now we would like to give a brief overview of the next two chapters: firstly, in the \chapref*{Technologies} we will give a proper introduction into the technologies we used to implement the described protocol and, then, in the \chapref*{Implementation} we will go through its development.
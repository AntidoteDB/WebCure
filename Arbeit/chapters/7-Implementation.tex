\chapter{Implementation}
\label{Implementation}

In this chapter, we are going to explain the major problems that we encountered during the development phase.

Addressing the client, in the \chapref*{Technologies} we already named the key frameworks and techniques that we used in the implementation. Concerning the server, which is going to provide to the client the RESTful\footnote{REST or Representational State Transfer is a set of design principles, which make the network communication more flexible and scalable\cite{40}.} interface, we will cover the use cases.

\begin{figure}[!htb]
    \begin{center}
    \setlength{\fboxsep}{4pt}%
    \setlength{\fboxrule}{1pt}%
    \stackunder{\fbox{\includegraphics[width=0.5\linewidth]{images/design/clientserver.jpeg}}}%
    {\scriptsize%
     Source: \url{https://cdn-images-1.medium.com/max/660/1*EbBD6IXvf3o-YegUvRB_IA.jpeg}}
    \caption {A look at the server-client architecture with a RESTful interface.}
    \label{fig:design1}
\end{center}
\end{figure}

To demonstrate the functionality of the WebCure, we covered three different types of CRDTs used in AntidoteDB: a Counter, a Set and a Multi-value Register. We managed to support each of these data types on the server and the client as well. We will use a Set CRDT as an example for code listings introduced further.

\section{System's main components}

\begin{figure}[!htb]
    \begin{center}
        \setlength{\fboxsep}{15pt}%
        \setlength{\fboxrule}{1pt}%
    \def\svgwidth{\linewidth}
    \fbox{\input{images/design/Main.pdf_tex}}
    \caption {A top-level view of the system's design.}
    \label{fig:impl1}
\end{center}
\end{figure}

In the chapter \chapref*{Design}, we introduced a client and a server as blackboxes, without really knowing what is happening inside each of them. However, from now on, we have a clear understanding of what the system and its main components will look like. As you can see at the \figref*{fig:impl1}, the client part of the system, which we introduced before contains a web application that has a database on its side for reading and storing the data locally. The server, on the other hand, posseses a setup with AntidoteDB and, apart from that, is able to exchange messages with a client. Regarding the exchanging of the data, as was mentioned before, the client is able to send to the server the operations performed offline, while the server is sending back to the client the current states of CRDT data.

\begin{figure}[!htb]
    \begin{center}
    \def\svgwidth{\linewidth}
    \input{images/implementation/3tier.pdf_tex}
    \caption {3-Tier architecture.}
    \label{fig:dev1}
\end{center}
\end{figure}

We are going to implement the WebCure using a 3-tier architecture\cite{51}, as it suits the design we introduced. Its main distinction is that it has a clear separation between the presentation, application and data layers, as you can spot at the \figref*{fig:dev1}, where we also noted how each JavaScript file of the WebCure relates to these layers. Each layer is responsible for their own tasks. Let us now briefly characterize each of them. A \textit{presentation layer} is responsible for presenting the information to the users, while it can also accept requests from them. An \textit{application layer}, in its turn, implements the algorithmic part of the system and answers the operations requested by the clients. The last one, a \textit{data layer}, manages and implements the data sources of the system. The advantages of a 3-tier architecture style are the scalability and portability it provides. However, a disadvantage could be a communication overhead between the layers\cite{50}.

In the next subsections, we are going to describe how the main logic of the system was implemented.

\subsection{Database layer}

This layer includes an AntidoteDB database, which is used to store and hadle CRDT-objects. To be able to work with the database, we are going to use a JavaScript Client for AntidoteDB\cite{52}, which suits the stack of the technologies we are using for WebCure. The database itself will be running on a Docker\footnote{https://www.docker.com/} container created from an image of Antidote data store. For this thesis, however, specific changes were applied to the docker image of Antidote and to the JavaScript Client for Antidote as well. In order to be able to read and to apply changes to the data at a specific timestamp, the Antidote image for docker should be running with certifications checks disabled, while the Antidote JavaScript client was added an additional flag to make sure that the client supports the possibility of making transactions at specific timestamps. Apart from that, the database was also changed to support this functionality. The data in AntidoteDB is stored as a binary data. The serialization process is performed by the Antidote JavaScript Client.

\subsection{Server}

The server side of the WebCure is very important, as it provides the interface to the client and manages the communcation with the database layer. To implement a server we used a Node.js\footnote{Node.js is a JavaScript run-time environment, which let us execute JavaScript code outside the web browser. More details can be found here: https://nodejs.org/en/.} framework called Express\footnote{Express is a Nodej.s framework that provides features for web and mobile applications. More details can be found here: https://expressjs.com/.}. As we are taking Set CRDT as an example, let us mention the methods the server has for it:

\begin{itemize}
    \item {Sending back either the latest state of a Set CRDT or, if a timestamp was provided, then the state at a specific timestamp;}
    \item {Adding / removing elements from the Set CRDT;}
    \item {Applying all the add and remove operations, which were performed at the client while offline;}
\end{itemize}

\subsection*{Sending the data back}

In this section, we will describe how we implemented the functionality of the server to sent back the data requested by the client .

\begin{lstlisting}[caption={Code for sending back to the client the requested data.}, label={lst:dev1}]
apiRouter.route('/set/:set_id/timestamp').post(async function(req, res, next) {   
     /// ...
    
    var setId = req.params.set_id;
    var timestamp = req.body.timestamp;

    setTimestamp(timestamp, ...);

    let tx = await atdClient.startTransaction();
    let set = tx.set(setId);
    let val = await set.read();

    await tx.commit();

    // ...
    res.json({
      status: 'OK',
      cont: val,
      lastCommitTimestamp: atdClient.getLastCommitTimestamp().toBase64()
    });
   // ... 
});
\end{lstlisting} 

Have a look at the~\lstref*{lst:dev1}, where at the \textit{line 1} there is an object \textit{apiRouter} from Express framework inroduced above, which adds an HTTP Post route to listen for. As a response to that request, starting from \textit{line 5} we can observe the logic of the function. There, firstly, we assign variables the passed parameters. The id of the requested Set CRDT is assigned to the variable \textit{setId} and an optional timestamp, if it was passed, is assigned to the variable \textit{timetamp}, which is used in the function \textit{setTimestamp} to set the current timestamp of the database. That let us making updates at any timestamp and maintain the sequence of updates.

At \textit{line 10} we use the asynchronous method \textit{startTransaction} of object \textit{atdClient}, which represents the Antidote JavaScript Client. From that point, a reference of the Antidote Object associated with \textit{setId} is assigned to the variable \textit{set} and aftervards its value is read and assigned to \textit{val}. Then, at the \textit{line 13} the transaction is commited and, afterwards, a JSON object containing the status of the request, the value of requested Set CRDT and the timestamp of the transaction (as the timestamp is an object representing a type of ByteBuffer\footnote{https://github.com/dcodeIO/bytebuffer.js}, for a successful transmission in a JSON format, it is converted to the Base64\footnote{Base64 -- a group of similar binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation\cite{53}.} at \textit{line 20}) is sent back to the client.

\subsection*{Adding / removing elements}

As operations of adding and removing elements from the Set CRDT do not differ in terms of implementation, we will use the operation of adding elements as an example for further explanation.

\begin{lstlisting}[caption={Code for applying an \textit{add} operation to a Set CRDT.}, label={lst:dev2}]
apiRouter
  .route('/set/:set_id')
  .put(async function(req, res, next) {
     /// ...

      var setId = req.params.set_id;
      var value = req.body.value;      

      let tx = await atdClient.startTransaction();
      let set = tx.set(setId);
      await tx.update(set.add(value));
      await tx.commit();

    // ...
      res.json({
        status: 'OK'
        // ...
      });
    // ...
  })
\end{lstlisting} 

As we can see from the~\lstref*{lst:dev2}, this code looks very similar to what we have already seen before, with some small differences. At the \textit{line 7}, for example, we now get the passed by a client value and assign it to the \textit{value} variable. Afterwards, we start a transaction and at the \textit{line 10} assign to the variable \textit{set} an Antidote Object associated with \textit{setId}. Later, we perform an operation \textit{update} of the transaction object \textit{tx} and call the method \textit{add} of object \textit{set}, passing it the \textit{value}. Finally, we commit the transaction and send back to the client the status of request.

\subsection*{Applying the operations performed offline}

Now, let us have a look at server's logic when it comes to syncronizing the operations, which were performed at the client offline and were sent to the server when the internet connection was re-established.

\begin{lstlisting}[caption={Code for applying an \textit{add} operation to a Set CRDT.}, label={lst:dev3}]
apiRouter.route('/set_sync/:set_id').post(async function(req, res, next) {
    // ...
    var setId = req.params.set_id;
    var lastCommitTimestamp = req.body.lastCommitTimestamp;
    var updates = req.body.updates;

    setTimestamp(lastCommitTimestamp, false);
    let tx = await atdClient.startTransaction();
    let set = tx.set(setId);

    var antidoteUpdates = [];
    updates.forEach(element => {
      if (element.type === 'add') {
        antidoteUpdates.push(set.add(element.value));
      } else if (element.type === 'remove') {
        antidoteUpdates.push(set.remove(element.value));
      }
    });

    await tx.update(antidoteUpdates);
    await tx.commit();
    
    // ...

    res.json({
      status: 'OK'
    });
   // ...
});
\end{lstlisting}

At the~\lstref*{lst:dev3}, we can see the server's implementation for this case. We are interested the most in the part, which starts at \textit{line 11}. There, we create an empty array named \textit{antidoteUpdates}, where we are going to store the updates from the client in the order in what they were received. To do that, we start iterating using \textit{forEach} over the elements of the array \textit{update}, which was received through the POST request from the client. The updates from the client arrive to the server's side in such a format, which allows to distinguish between the operations applied on the Set CRDT -- either \textit{add} or \textit{remove}. We can clearly see it inside the loop between the lines \textit{13} and \textit{17}. Afterwards, we have the array, consisting Antidote-compatible updates. Then, the important  point is to apply these updates at the timestamp, which the client had on its side, as there could be other updates coming from different clients which could have been online at that time. For this reason, at the \textit{line 4} we store a timetamp coming from the client, which is the latest it received from the server before going offline. Thus, we apply the updates on that timestamp, to satisfy causal consistency guarantees.

\subsection{Client}

In order for the user to be able to communicate with an AntidoteDB server, we are going to have a running web application that serves as a client. It runs in the web-browser, supports various commands from the user and sits on top of the local database layer.

\begin{figure}[!htb]
    \begin{center}
    \setlength{\fboxsep}{4pt}%
    \setlength{\fboxrule}{1pt}%
    \stackunder{\fbox{\includegraphics[width=0.6\linewidth]{images/screens/Overview.PNG}}}%
    {\scriptsize}
    \caption {A part of the WebCure interface on working with Sets.}
    \label{fig:dev2}
\end{center}
\end{figure}
 

For each of supported CRDTs, there are different available commands, which we can observe from the \figref*{fig:dev2}. For the demonstaration of the functionality, there are three inputs available to the user. The first input labeled \textit{Set Id}, is responsible for the names of the elements stored in the local cache and in the AntidoteDB. The second input, \textit{Element}, is there for the user to enter a list of elements to add or remove from the Set CRDT. The last input gives an opportunity to provide a specific timestamp, in order to be able to get the data at that timestamp or, in the other case, to apply a selected operation at that timestamp. Apart from the inputs, there are four buttons, which perform specific operations on a set CRDTs -- \textit{getting the value by id}, \textit{adding and removing elements}, \textit{removing element by id from the cache}.

However, for all this functionality to work as intended in both modes -- offline and online -- at first, a service worker has to be set up. 

\subsection*{Setting up a service worker}

Our service worker lies in the root directory of the application under the file \textit{sw.js}. Due to it, the application is able to maintain its main features such as support the offline work and syncrhonizing the changes performed offline with the main database. As it was explained in the Technologies chapter, we registered the service worker on \textit{load} event of the application. Then, we added two listeners to the service worker for the events \textit{install} and \textit{fetch}, which we are going to explain further.

\begin{lstlisting}[caption={Code for caching neccessary data for the client.}, label={lst:dev4}]
self.addEventListener('install', function(event) {
  // Mention URLS that need to be cached
  // It is required in order for the application to work offline
  var urlsToCache = [
    // root
    '/',
    '/index.html',
    // js
    '/logger.js',
    '/main.js',
    '/dbhelper.js',
    '/idb.js',
    // js CRDTs
    '/CRDTs/CounterCRDT.js',
    '/CRDTs/SetCRDT.js',
    '/CRDTs/MVRegisterCRDT.js',
    // css
    '/styles.css',
    // images
    'img/icon-192.png',
    'img/icon-512.png',
    'img/favicon.ico',
    // manifest
    'manifest.json'
  ];

  event.waitUntil(
    caches.open(CACHES_NAME).then(function(cache) {
      // Add all mentioned urls to the cache, so the app could work without the internet
      return cache.addAll(urlsToCache);
    })
  );
});
\end{lstlisting}

At the \lstref*{lst:dev4}, we can see that the array \textit{urlsToCache} consists of elements of type JavaScript strings, which are all the required frameworks, libriraries, HTML pages, CSS styles and images needed for the application to work properly. This array is later used to create a cache storage \textit{CACHES\_NAME}, where the responses to the stored urls from the array \textit{urlsToCache} are going to be stored. All this work is performed when the installation of the service worker for the page is triggered, which in our case is the start of the application. 

\begin{lstlisting}[caption={Code for maintaining the requests of the application.}, label={lst:dev5}]
self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request).then(function(response) {
      // Respond the data from the cache, if it was found there. Otherwise, fetch from the network.
      return response || fetch(event.request);
    })
  );
});
\end{lstlisting}

Now, once the we already have the cached data, we still need to make use of it to make our application work offline. If we look at \lstref*{lst:dev5}, we can see that whenever there is a request going to the network, at \textit{line 3} we are trying to match that request with ones we have in cache: if it is the case, then the cached object is returned or, otherwise, the fetching process from the network continues, as can be seen at the \textit{line 5}.

Apart from caching neccessary for the application to work scripts and media files, we will need to setup a local database to store the data at client's side.

\subsection*{Setting up a local database}

As it was explained in the technologies chapter, in the file \textit{js/dbhelper.js} we are setting up an IndexedDB database for the client's side. There, we are going to create two object stores. First one will consist different CRDT data items, diffirintiated by id. The other object store will keep the track of the timestamp, which is associated with the latest data taken from the server. The point of having that timestamp is for the client to send it with the updates performed while offfline, which will give an insight to the server, at which timestamp these updates should be applied.

\begin{lstlisting}[caption={Creating object stores in IndexedDB for CRDTs and timestamps.}, label={lst:dev6}]
// ...
var stateStore = upgradeDB.createObjectStore('crdt-states', \{
  keyPath: 'id'
\});

var snapshotStore = upgradeDB.createObjectStore('crdt-timestamps', \{
  keyPath: 'id'
\});
// ...
\end{lstlisting}

We can observe the logic explained above at \lstref*{lst:dev6}, where there is an object store named \textit{crdt-states} created for CRDTs and \textit{crdt-timestamps} for the timestamp. A \textit{keyPath} parameter for both of them is there in order to be able to query the data by \textit{id}.

\subsection*{Implementation of abstract Set CRDT type}

Next, let us introduce our implementation of Set CRDTs abstraction for the client's side, which helps to maintain the data received by the server.

\begin{lstlisting}[caption={A class Set CRDT, objects of which are going to be stored in the \textit{crdt-states} object store.}, label={lst:dev7}]
class SetCRDT {
  constructor(id, values) {
    this.id = id;
    this.state = values ? new Set(values) : new Set();
    this.type = 'set';
    this.operations = [];
    this.sentOperations = [];
  }

  processSentOperations() {
    if (this.operations.length > 0) {
      this.operations.forEach(operation => {
        this.sentOperations.push(operation);
      });
      this.operations = [];
    }
  }

  calculateState() {
    let values = [];

    if (this.sentOperations.length > 0) {
      this.sentOperations.forEach(operation => {
        if (operation.type === 'add') {
          this.state.add(operation.value);
        } else if (operation.type === 'remove') {
          this.state.delete(operation.value);
        }
      });
    }

    if (this.operations.length > 0) {
      this.operations.forEach(operation => {
        if (operation.type === 'add') {
          this.state.add(operation.value);
        } else if (operation.type === 'remove') {
          this.state.delete(operation.value);
        }
      });
    }

    this.state.forEach(key => {
      values.push(key);
    });

    return values;
  }

  add(valueToAdd) {
    let operation = {
      type: 'add',
      value: valueToAdd
    };

    this.operations.push(operation);
  }

  remove(valueToRemove) {
    let operation = {
      type: 'remove',
      value: valueToRemove
    };

    this.operations.push(operation);
  }
}
\end{lstlisting}

First, let us have a look at the constructor of a Set CRDT class at the \lstref*{lst:dev7}, which takes two parameters -- an \textit{id} and, optionally, an array of values. The class has the following properties: 

         \begin{itemize}
         \item \textit{id} -- a string corresponding to the id of the data element stored in the server's database;
         \item \textit{state} -- a JavaScript Set, which reflects the state of the SetCRDT and behaves like sets;
	\item \textit{type} -- a string reflecting the datatype and is needed for the client to distinguish between different CRDTs;
	\item \textit{operations} -- an array, which consists of operations performed offline at the client;
	\item \textit{sentOperations} -- an array, which consists of operations performed offline, but which are already sent to the server;
     \end{itemize}

Secondly, there are the methods, which ease the process of working with Set CDRTs at the client: 

         \begin{itemize}
         \item \textit{processSentOperations()} -- shifts offline performed operations to the \textit{sentOperations} property in order to have a distinction for the operations, which are already sent to the client.
         \item \textit{calculateState} -- returns the current state of the CRDT Set, taking into account the operations performed offline.
         \item \textit{add} -- performs an offline operation of adding an element to the Set CRDT, takes an element to add as a parameter.
          \item \textit{remove} -- performs an offline operation of removing an element from the Set CRDT, takes an element to remove as a parameter.
     \end{itemize}

\begin{lstlisting}[caption={An example of a Set CRDT stored on a client's side.}, label={lst:dev8}]
{
id: "a",
operations: [{type: "add", value: "c"}],
sentOperations: [],
state: Set(2) {"b", "d"},
type: "set"
}
\end{lstlisting}
     
Having now undestood the structure of the data stored on a client's side, as well as the way it is managed, let us look at the \lstref*{lst:dev8}, where an example of a Set CRDT element \textit{a} is shown. As can be seen, it has a state received from the server of \textit{\{``b'', ``d''\}}, while also having an offline operation \textit{add(c)} performed on it, which is still about to be sent to the server, as an array \textit{sentOperations} is empty at this example.

As we have already explained the server's side logic earlier, in the following sections we will only touch the topic of a client's offline work and the logic happening  at the client on a transition from offline to online modes. We believe that the part, which is related to the online work of the client is already obvious for the reader, as it comes down to sending particular requests and this part was already covered when explaining the server's side. 

\subsection*{Read}

One of the important aspects of the client working offline as intended is storing the CRDT states received from the server. Let us further explain the logic behind the implementation of it.

\begin{lstlisting}[caption={Storing CRDT states in cache after a successful request from the server.}, label={lst:dev9}]
DBHelper.crdtDBPromise
  .then(function(db) {
  // ...

    var tx = db.transaction('crdt-states', 'readwrite');
    var store = tx.objectStore('crdt-states');

    var item = new SetCRDT(id, value);

    store.put(item);

// ...

    return tx.complete;
  })
  .then(function() {
    DBHelper.crdtDBPromise.then(function(db) {
// ...

     var tx = db.transaction('crdt-timestamps', 'readwrite');
     var store = tx.objectStore('crdt-timestamps');

     if (temp) {
       store.put({ id: 0, data: lastCommitTimestamp });
     }

     return tx.complete;
    });
  });
\end{lstlisting}

At \lstref*{lst:dev9}, \textit{DBHelper.crdtDBPromise} at the \textit{line 1} gives us an access to the IndexedDB database consisting the object stores we created. There, we create a transaction on a \textit{`crdt-states'} object store and at the \textit{line 8} we create an element of SetCRDT class introduced above, passing it the \textit{id} of the Set CRDT and its \textit{value} that was just received from the server. Then we assign it to the variable \textit{item} and add this \textit{item} to the object store of CRDT states using the method \textit{put} of \textit{store} object. Next, we close the transaction using \textit{complete} of transaction \textit{tx} object.

Next, when we successfully stored the received state, there is another piece of information that has to be saved on the client as well. This time it is a timestamp associated with the update we received. Looking again at the \lstref*{lst:dev9}, at \textit{line 20} we refer to the \textit{crdt-timestamps} object store this time. In the similar way just as before, as can be seen at the \textit{line 25}, we store store \textit{lastCommitTimestamp}, which consits the timestamp received from the server. That happens each time we get a new update from the server.


\begin{lstlisting}[caption={Reading CRDT states from client's cache.}, label={lst:dev10}]
DBHelper.crdtDBPromise.then(function(db) {
// ...

  var index = db.transaction('crdt-states').objectStore('crdt-states');

  return index.get(id).then(function(state) {
    if (state) {
     Object.setPrototypeOf(state, SetCRDT.prototype);
     log('[Offline] The value of ' + name.value + 'is: [ ' + state.calculateState() + ']');
    } else {
     log('[Offline] Selected key is not available offline.');
    }
  });
});
\end{lstlisting}

Now comes the part regarding reading the states of the Set CRDTs from the cache. We can have a look at \lstref*{lst:dev10}, where the code already looks familiar to us. There, at the \textit{line 6}, we use the method \textit{get} of \textit{index} to search by the property \textit{id} of the object. Then, if an element with such \textit{id} was found in the object store, we are going to have it in a \textit{state} variable. As we don't store the class information in the client's database, we will have to ``remind'' the object we have in the \textit{state} variable about its prototype. That is why a method \textit{Object.setPrototypeOf} is used with \textit{state} and \textit{SetCRDT.prototype} as parameters. After that, the object \textit{state} will have an access to \textit{SetCRDT}'s methods. For the demonstration of the client's functionality, in this thesis we are using a JavaScript Logger\footnote{http://www.songho.ca/misc/logger/logger.html} library, which we have an access to under the \textit{log} variable at \textit{lines 9 and 11}. It let us keep the track of neccessary information in a convinient manner. As can be seen, at \textit{line 9} we log the actual state of the Set CRDT using a \textit{calculateState()} method of \textit{SetCRDT} class.

\subsection*{Add / Remove}

Another functionality that a client covers, apart from reading and storing the values in cache, it is performing the operations on CRDTs offline.

\begin{lstlisting}[caption={Reading CRDT states from client's cache.}, label={lst:dev11}]
DBHelper.crdtDBPromise
  .then(function(db) {
// ...

    var index = db.transaction('crdt-states').objectStore('crdt-states');

    return index.get(id).then(function(storedValue) {
      var tx = db.transaction('crdt-states', 'readwrite');
      var store = tx.objectStore('crdt-states');

      Object.setPrototypeOf(storedValue, SetCRDT.prototype);
      storedValue.add(value);
      store.put(storedValue);

      return tx.complete;
    });
  });
\end{lstlisting}

Looking at the \lstref*{lst:dev11}, we can see that there is not so much of a difference with previous code that we have seen on performing the read operations from the IndexedDB. Again, as we can see from the example, a transaction on a \textit{`crdt-states'} object store is created and if an element with \textit{id} is found in the object store, its value will be available under the variable \textit{storedValue}. Then, similarly, the method \textit{Object.setPrototypeOf} is used for the \textit{storedValue}, in order for it to have an access to the \textit{SetCRDT} class methods. Once it is done, at \textit{line 12} we use the method \textit{storedValue.add(value)}, where \textit{value} is the value entered by the user. If we get back to the \lstref*{lst:dev7}, we will remember that it will add an element to the array-type property \textit{operations} of the object \textit{storedValue}. Finally, we uset \textit{store.put(storedValue)} to put the update data item back to the client's database and afterwards complete the transaction. Similarly, the same happens when a user tries to remove elements from Set CRDTs.

\subsection*{Transition from offline to online}






\section{Optimization}
PUT INTO THE OPTIMIZATION PART:
- sending all offline operations at once